# scheme_symbolic_math
The goal here is to build a Scheme program that can do calculus symbolically. The goal here is for it to be able to handle any derivative or integral found in standard undergraduate calculus, although that's probably quite far off. At present, it can handle:

Derivatives of single-variable functions including algebraic functions, the main trigonometric and inverse trigonometric functions, the exponential and natural log, and any product, composition, etc. of the above. Differentiation of exponentiations with arbitrary bases is implemented, but for logarithms, only natural logs work. Possible "next steps" here include implementing some of the less important trig functions, logs with bases other than e, and perhaps some more obscure things like hyperbolic functions. A more ambitious goal would be implicit differentiation, but that would involve much more algebra than the program is currently able to handle.

Partial derivatives of functions R^n -> R, involving any of the functions and operations listed above. Possible next steps include derivatives of more general functions R^n -> R^m, as well as some vector calculus operations like gradient and divergence.

Generation of (finite) Taylor series for single-variable functions that the program can differentiate. Possible next steps include Taylor series of multivariable functions, finding remainder terms, and implementing Taylor series as streams to allow for more easily working with Taylor series of arbitrary length.

Some very basic integration capabilities. Currently this just means finding indefinite and definite integrals of polynomials and a tiny handful of easy-to-integrate functions. Possible next steps include, uh, the rest of single-variable integral calculus: a larger "table" of integrals and support for common techniques like integration by parts. 

All of this is built on top of a system for representing mathematical expressions made with numbers, variables, the 4 basic operations, exponentiation, natural logs and some special functions (mainly just the basic trig functions). An expression is either a number, a variable, a list of 3 elements consisting of 2 expressions separated by a binary operator, or a list of 2 elements of which the first is a unary operator (e.g. sin) and the second is an expression. (A consequence of this is that expressions are always fully parenthesized.) While expressions could in principle be built directly using quoted lists or the list function, it's best to create them using the included constructors (which are used by the differentiation and integration programs). These automatically simplify expressions so that, for instance, the sum of x and 0 is always just x. These constructors also help keep expressions in a form that's easier for the differentiation and integration programs to deal with. For instance, the product constructor always puts numerical factors first, which makes it easier for the indefinite integral function to find and "pull out" constants. 

The "mathematical-expressions" file contains all these constructors as well as some other useful functions. For example, there's a function for evaluating expressions (given some assignment of numeric values to variables) with a simple recursive process. One can also turn expressions into executable functions with a function that's essentially just a wrapper around the evaluator function. Both of these currently only really work for expressions with one variable. 

Possible things to add beyond what was listed above: the ability to define and (where possible) differentiate and integrate piecewise functions. Allowing for expressions that aren't fully parenthesized, instead using standard order of operations rules. (Since fully parenthesized expressions are much nicer to deal with, this would probably come in the form of functions that can parse unparenthesized input into parenthesized input and vice versa.)
